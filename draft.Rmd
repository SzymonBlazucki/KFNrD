---
title: "My first project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='asis', echo=FALSE, message=FALSE}
cat(
  "<script src='https://cdn.jsdelivr.net/npm/vue'></script>",
  "<script src='https://unpkg.com/quantum-tensors'></script>",
  "<script src='https://unpkg.com/bra-ket-vue'></script>"
)
```

The purpose of that project is to visualize operations on three coloured [<span id="R"> R </span>, <span id="G"> G </span>, <span id="B"> B </span>] light beam. We'll start with the simple ones like filtration or fluorescence and then move on to the more advanced ones.

### Filtration

So at the beginning let's start with the simplest one - filtration. If we consider our light beam as a 3-dimensional vector where each dimension represents one component we can describe every operation as multiplying our vector by a matrix. For a blue light filter we have: 

$$ \begin{bmatrix}
R\\
G\\
B
\end{bmatrix} \begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 0
\end{bmatrix} = \begin{bmatrix} R\\ G\\0 \end{bmatrix}
$$
It's completely ok to write it like this, but that's not intuitive for everyone. Especially if you are not familiar with linear algebra. To make it easier and more straightforward let's draw a matrix not as a set of 0 and 1 but as a table with circles inside it. Colour of each circle represents the component which it affects. Take a look on the following examples 

$$ \begin{bmatrix}
R\\
G\\
B
\end{bmatrix}\rightarrow \begin{bmatrix} R\\ G\\0 \end{bmatrix}
$$

<div id='op-filtr'></div>

<div id='ketview-filtr'></div>

###Fluorescence
$$ \begin{bmatrix}
R\\
G\\
B
\end{bmatrix} \rightarrow \begin{bmatrix} R+G+B\\ 0\\0 \end{bmatrix}
$$
<div id='op-fluR'></div>

###Another type of fluorescence
$$ \begin{bmatrix}
R\\
G\\
B
\end{bmatrix} \rightarrow \begin{bmatrix} 0\\ G+B\\0 \end{bmatrix}
$$
<div id='op-fluGkillR'></div>



```{js, results='asis', echo=FALSE, message=FALSE}
const { Elements, Operator, Dimension, Cx } = QuantumTensors;
const { ComplexLegend, MatrixViewer } = BraKetVue;

const opNot = Operator.fromSparseCoordNames([
  ['0', '0', Cx(1)],
  ['1', '1', Cx(1)],
], [Dimension.position(3, 'color')]);

const opNott = Operator.fromSparseCoordNames([
  ['0', '0', Cx(1)],
  ['0', '1', Cx(1)],
  ['0', '2', Cx(1)],
], [Dimension.position(3, 'color')]);

const opNottt = Operator.fromSparseCoordNames([
  ['1', '1', Cx(1)],
  ['1', '2', Cx(1)],
], [Dimension.position(3, 'color')]);

new Vue({
  el: "#op-filtr",
  template: "<matrix-viewer :operator-raw='opNot' :dark-mode='false' :show-legend='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
    	opNot
		}
  }
})
new Vue({
  el: "#op-fluR",
  template: "<matrix-viewer :operator-raw='opNott' :dark-mode='false' :show-legend='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
    	opNott
		}
  }
})

new Vue({
  el: "#op-fluGkillR",
  template: "<matrix-viewer :operator-raw='opNottt' :dark-mode='false' :show-legend='false' />",
  components: {
    MatrixViewer
  },
  data() {
  	return {
    	opNottt
		}
  }
})
```

```{js, results='asis', echo=FALSE, message=FALSE}
const { Elements, Vector, Operator, Dimension, Cx } = QuantumTensors;
const { ComplexLegend, MatrixViewer, KetWiever } = BraKetVue;

const singlet = Vector.fromSparseCoordNames(
  [["ud", Cx(1/3)], ["du", Cx(1/3)]],
  [Dimension.spin(), Dimension.spin()]
);

new Vue({
  el: "#ketview-filtr",
  template: "<ket-viewer :operator-raw='ketview-filtr' :dark-mode='false' :show-legend='false' />",
  components: {
    KetViewer
  },
  data() {
  	return {
    	singlet
		}
  }
})

```




```{css, echo=FALSE}
#R {
  color: red;
}
#G {
  color: green;
}
#B {
  color: blue;
}
```